{"version":3,"sources":["webpack:///./node_modules/core-js/modules/es.symbol.iterator.js","webpack:///./node_modules/vuetify/lib/util/mergeData.js"],"names":["defineWellKnownSymbol","pattern","styleList","styleProp","parseStyle","style","styleMap","split","s","key","val","trim","camelize","mergeData","prop","event","mergeTarget","i","arguments","length","Object","keys","Array","isArray","j","concat","undefined","listeners"],"mappings":"qJAAA,IAAIA,EAAwB,EAAQ,QAIpCA,EAAsB,a,w0BCHtB,IAAMC,EAAU,CACdC,UAAW,gBACXC,UAAW,SAGb,SAASC,EAAWC,GAClB,IAAMC,EAAW,GADQ,uBAGzB,YAAgBD,EAAME,MAAMN,EAAQC,WAApC,+CAAgD,KAArCM,EAAqC,UAC7BA,EAAED,MAAMN,EAAQE,WADa,sBACzCM,EADyC,KACpCC,EADoC,KAE9CD,EAAMA,EAAIE,OAELF,IAKc,kBAARC,IACTA,EAAMA,EAAIC,QAGZL,EAASM,eAASH,IAAQC,IAhBH,kFAmBzB,OAAOJ,EAGM,SAASO,IACtB,IAEIC,EACAC,EAHEC,EAAc,GAChBC,EAAIC,UAAUC,OAIlB,MAAOF,IAGL,cAAaG,OAAOC,KAAKH,UAAUD,IAAnC,eACE,OADGH,EAAmC,KAC9BA,GAEN,IAAK,QACL,IAAK,QACL,IAAK,aACH,IAAKI,UAAUD,GAAGH,GAChB,MAOF,GAJKQ,MAAMC,QAAQP,EAAYF,MAC7BE,EAAYF,GAAQ,IAGT,UAATA,EAAkB,CACpB,IAAIT,OAAK,EAGPA,EADEiB,MAAMC,QAAQL,UAAUD,GAAGZ,OACrBa,UAAUD,GAAGZ,MAEb,CAACa,UAAUD,GAAGZ,OAGxB,IAAK,IAAImB,EAAI,EAAGA,EAAInB,EAAMc,OAAQK,IAAK,CACrC,IAAMhB,EAAIH,EAAMmB,GAEC,kBAANhB,IACTH,EAAMmB,GAAKpB,EAAWI,IAI1BU,UAAUD,GAAGZ,MAAQA,EAKvBW,EAAYF,GAAQE,EAAYF,GAAMW,OAAOP,UAAUD,GAAGH,IAC1D,MAGF,IAAK,cACH,IAAKI,UAAUD,GAAGH,GAChB,WAGwBY,IAAtBV,EAAYF,KACdE,EAAYF,GAAQ,IAGlBE,EAAYF,KAEdE,EAAYF,IAAS,KAGvBE,EAAYF,IAASI,UAAUD,GAAGH,GAAMH,OACxC,MAOF,IAAK,KACL,IAAK,WACH,IAAKO,UAAUD,GAAGH,GAChB,MAGGE,EAAYF,KACfE,EAAYF,GAAQ,IAKtB,IAFA,IAAMa,EAAYX,EAAYF,GAE9B,MAAcM,OAAOC,KAAKH,UAAUD,GAAGH,IAAS,IAAhD,eAAKC,EAAgD,KAE/CY,EAAUZ,GAEZY,EAAUZ,GAASO,QAAQG,OAC3BE,EAAUZ,GAAQG,UAAUD,GAAGH,GAAMC,IAGrCY,EAAUZ,GAASG,UAAUD,GAAGH,GAAMC,GAI1C,MAGF,IAAK,QACL,IAAK,QACL,IAAK,WACL,IAAK,cACL,IAAK,cACL,IAAK,OACL,IAAK,aACH,IAAKG,UAAUD,GAAGH,GAChB,MAGGE,EAAYF,KACfE,EAAYF,GAAQ,IAGtBE,EAAYF,GAAZ,KAAyBI,UAAUD,GAAGH,GAAtC,GACKE,EAAYF,IAEjB,MAGF,IAAK,OACL,IAAK,MACL,IAAK,MACL,IAAK,MACL,IAAK,OACL,IAAK,YACL,QACOE,EAAYF,KACfE,EAAYF,GAAQI,UAAUD,GAAGH,IAO3C,OAAOE","file":"js/chunk-e7aea084.38265178.js","sourcesContent":["var defineWellKnownSymbol = require('../internals/define-well-known-symbol');\n\n// `Symbol.iterator` well-known symbol\n// https://tc39.github.io/ecma262/#sec-symbol.iterator\ndefineWellKnownSymbol('iterator');\n","import { camelize } from './helpers';\nconst pattern = {\n  styleList: /;(?![^(]*\\))/g,\n  styleProp: /:(.*)/\n};\n\nfunction parseStyle(style) {\n  const styleMap = {};\n\n  for (const s of style.split(pattern.styleList)) {\n    let [key, val] = s.split(pattern.styleProp);\n    key = key.trim();\n\n    if (!key) {\n      continue;\n    } // May be undefined if the `key: value` pair is incomplete.\n\n\n    if (typeof val === 'string') {\n      val = val.trim();\n    }\n\n    styleMap[camelize(key)] = val;\n  }\n\n  return styleMap;\n}\n\nexport default function mergeData() {\n  const mergeTarget = {};\n  let i = arguments.length;\n  let prop;\n  let event; // Allow for variadic argument length.\n\n  while (i--) {\n    // Iterate through the data properties and execute merge strategies\n    // Object.keys eliminates need for hasOwnProperty call\n    for (prop of Object.keys(arguments[i])) {\n      switch (prop) {\n        // Array merge strategy (array concatenation)\n        case 'class':\n        case 'style':\n        case 'directives':\n          if (!arguments[i][prop]) {\n            break;\n          }\n\n          if (!Array.isArray(mergeTarget[prop])) {\n            mergeTarget[prop] = [];\n          }\n\n          if (prop === 'style') {\n            let style;\n\n            if (Array.isArray(arguments[i].style)) {\n              style = arguments[i].style;\n            } else {\n              style = [arguments[i].style];\n            }\n\n            for (let j = 0; j < style.length; j++) {\n              const s = style[j];\n\n              if (typeof s === 'string') {\n                style[j] = parseStyle(s);\n              }\n            }\n\n            arguments[i].style = style;\n          } // Repackaging in an array allows Vue runtime\n          // to merge class/style bindings regardless of type.\n\n\n          mergeTarget[prop] = mergeTarget[prop].concat(arguments[i][prop]);\n          break;\n        // Space delimited string concatenation strategy\n\n        case 'staticClass':\n          if (!arguments[i][prop]) {\n            break;\n          }\n\n          if (mergeTarget[prop] === undefined) {\n            mergeTarget[prop] = '';\n          }\n\n          if (mergeTarget[prop]) {\n            // Not an empty string, so concatenate\n            mergeTarget[prop] += ' ';\n          }\n\n          mergeTarget[prop] += arguments[i][prop].trim();\n          break;\n        // Object, the properties of which to merge via array merge strategy (array concatenation).\n        // Callback merge strategy merges callbacks to the beginning of the array,\n        // so that the last defined callback will be invoked first.\n        // This is done since to mimic how Object.assign merging\n        // uses the last given value to assign.\n\n        case 'on':\n        case 'nativeOn':\n          if (!arguments[i][prop]) {\n            break;\n          }\n\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {};\n          }\n\n          const listeners = mergeTarget[prop];\n\n          for (event of Object.keys(arguments[i][prop] || {})) {\n            // Concat function to array of functions if callback present.\n            if (listeners[event]) {\n              // Insert current iteration data in beginning of merged array.\n              listeners[event] = Array().concat( // eslint-disable-line\n              listeners[event], arguments[i][prop][event]);\n            } else {\n              // Straight assign.\n              listeners[event] = arguments[i][prop][event];\n            }\n          }\n\n          break;\n        // Object merge strategy\n\n        case 'attrs':\n        case 'props':\n        case 'domProps':\n        case 'scopedSlots':\n        case 'staticStyle':\n        case 'hook':\n        case 'transition':\n          if (!arguments[i][prop]) {\n            break;\n          }\n\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {};\n          }\n\n          mergeTarget[prop] = { ...arguments[i][prop],\n            ...mergeTarget[prop]\n          };\n          break;\n        // Reassignment strategy (no merge)\n\n        case 'slot':\n        case 'key':\n        case 'ref':\n        case 'tag':\n        case 'show':\n        case 'keepAlive':\n        default:\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = arguments[i][prop];\n          }\n\n      }\n    }\n  }\n\n  return mergeTarget;\n}\n//# sourceMappingURL=mergeData.js.map"],"sourceRoot":""}